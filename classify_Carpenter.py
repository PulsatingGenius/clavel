#! /usr/bin/env python

# Copyright (c) 2012 Felipe Gallego. All rights reserved.
#
# CLAVEL is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""
This module predicts the type of variability for stars.
The variability is predicted from the light curves of the stars. This
program calculates several features from these light curves that are
processed by means of machine learning techniques. 
The stars are retrieved from a database generated by LEMON 
(https://github.com/vterron/lemon/). 

"""

import csv
import sys
import classifargs
import database
import lsproperties
import lombscargle
import periodicfeature
import nonperiodicfeature
import trainevalsets
from sklearn.ensemble import RandomForestClassifier

def get_stars_classes():
    """ Read from a CSV file the list of star whose variability type is know.
        These stars are used to train and evaluate the classifier. """
    
    stars_ids = []
    stars_classes = []     
        
    csv_file_name = "Carpenter_ord.csv"        
    
    # Read csv file.
    with open(csv_file_name, 'rb') as csvfile:
        reader = csv.reader(csvfile, delimiter=',', quotechar='"')
        try:
            # For each row in csv file.
            for row in reader:
                # Add the first element of the row as the star id.
                stars_ids.append(row[0])
                # Add the second element of the row as the star type.
                stars_classes.append(row[1])
        except csv.Error as p:
            sys.exit('file %s, line %d: %s' % (csv_file_name, reader.line_num, p))    
            
    return stars_ids, stars_classes              
    
def save_features(perfeat, noperfeat):
    """ Save the star features in a list. """
    
    # This structure will contain all the features calculated for the stars
    # in each filter.
    features = []
    
    # Three frequencies are used.
    for n in range(3):
        # Append frequency attribute.
        features.append(perfeat.get_fund_freq(n))
        # Append amplitude attribute.
        features.append(perfeat.get_amplitude(n))
        # Append amplitude of three first harmonics.
        features.extend(perfeat.get_amplitude_firsts_harm(n))
        # Append frequencies offset
        features.extend(perfeat.freq_y_offset())
        
    # Add difference of amplitudes        
    features.append(noperfeat.amplitude_dif())
                    
    # Add percentage of values beyond 1 standard deviation.
    features.append(noperfeat.beyond1st())
                    
    # Add linear trend.
    features.append(noperfeat.linear_trend())
    
    # Add maximum slope.
    features.append(noperfeat.max_slope())
    
    # Add median_absolute_deviation.
    features.append(noperfeat.median_absolute_deviation())
    
    # Add percentage of values beyond 20% od median.
    features.append(noperfeat.median_buffer_range_percentage())
    
    # Add percentage o consecutive values with positive slope.
    features.append(noperfeat.pair_slope_trend())
    
    # Add percentage of biggest difference between maximum and minimum magnitude. 
    features.append(noperfeat.percent_amplitude())
    
    # Add differences of magnitudes between percentile 5 and 95.
    features.append(noperfeat.percent_difference_flux_percentile())
    
    # Add skew.
    features.append(noperfeat.skew())
    
    # Add Kurtosis.
    features.append(noperfeat.kurtosis())
    
    # Add standard deviation.
    features.append(noperfeat.std())
    
    # Add flux ratio at percentile 20.
    features.append(noperfeat.flux_percentile_ratio_mid20())
    
    # Add flux ratio at percentile 35.
    features.append(noperfeat.flux_percentile_ratio_mid35())
    
    # Add flux ratio at percentile 50.
    features.append(noperfeat.flux_percentile_ratio_mid50())
    
    # Add flux ratio at percentile 65.
    features.append(noperfeat.flux_percentile_ratio_mid65())
    
    # Add flux ratio at percentile 80.
    features.append(noperfeat.flux_percentile_ratio_mid80())    
        
    return features    


def calculate_features(filename, stars_ids):
    """ Calculate features of the stars. Read the light curves from
        database, calculate periodic and no periodic features and store
        all the features in a data structure. """
        
    # Container for all the features of the stars in all the filters available.
    carpenter_data = []        
    
    # Create database in LEMON format.
    db = database.LEMONdB(filename)
    
    # For each filter add an empty list to contain the features
    # of all the stars in that filter.
    for nfilter in range(len(db.pfilters)):
        carpenter_data.append([])
    
    # For all the stars in the database.
    for current_star_id in range(len(db.star_ids)):
        try:
            stars_ids.index(current_star_id)
            # For all the filters of current star.
            for nfilter in range(len(db.pfilters)):
                # Get the filter.
                pfilter = db.pfilters[nfilter]
                # Get the curve of the current star in the current filter.
                curve = db.get_light_curve(current_star_id, pfilter)
                lsprop = lsproperties.LSProperties()
                # Get the object that will calculate the periodgram of the curve
                # (not normalized).
                ls = lombscargle.LombScargle(current_star_id, pfilter, curve, lsprop)
                # Calculate the periodgram.
                pgram, nmags, ntimes = ls.calculate_periodgram()
                # Calculate periodic features of stars.
                perfeat = periodicfeature.PeriodicFeature(lsprop)
                # Calculate no periodic features of stars.
                noperfeat = nonperiodicfeature.NonPeriodicFeature(nmags, ntimes)
                # Save all the features of this star in a list.
                star_features_in_current_filter = save_features(perfeat, noperfeat)
                # Get the list where data of current filter is being added.
                filter_data = carpenter_data[nfilter]
                # Add the features calculated for the star in the appropriate
                # data structure.
                filter_data.append(star_features_in_current_filter) # Check if current star is in the list of stars whose type is known.
        
        except ValueError:
            pass
        
    return carpenter_data

def classify_Carpenter_db(classifarg):
    """ Performs a classification of stars stored in a LEMON database. """
        
    # Get the stars whose classes are know.
    stars_ids, stars_classes = get_stars_classes()
    
    # Calculate the features of the stars and return all the features in
    # a data structure.
    carpenter_data = calculate_features(classifarg.filename, stars_ids)
    
    # Calculates the training and evaluation sets.
    tr_ev_sets = trainevalsets.TrainEvalSet(classifarg.stars_set_min_cardinal,
                                            classifarg.training_set_percent,
                                            carpenter_data[0], # Only the first filter.
                                            stars_classes)
    
    # Get the list of unique class names.
    unique_classes_name_set = tr_ev_sets.get_unique_classes(stars_classes)

    # Get the set of classes but using a number to identify each class.
    numerical_classes_set = tr_ev_sets.get_numerical_classes_set(stars_classes, unique_classes_name_set)
 
    # Get the classifier.
    clf = RandomForestClassifier(classifarg.number_of_trees)
    
    clf = clf.fit(training_set, numerical_classes_set)
    
    self.evaluate_prediction(clf, evaluation_set, eval_set_class_names, unique_classes_name_set)  

def main(): 
    """ Main function. Process program arguments and determine if the stars
    to process are going to be retrieved from a LEMON database or any other
    source. The only argument necessary is the first one, related to the
    name of the file. """
    
    # Create object to process program arguments.
    ca = classifargs.ClassifierArguments()
    
    # Process program arguments and get the result.
    args_processing_result = ca.process_program_args()
    
    # Determines if there is any error in program arguments.
    if args_processing_result == ca.error_value:
        print "Error in arguments received by classifier"
    # Parameters of stars to classify are stored in a CSV file.
    elif ca.input_file_is_cvs == False:
        # In put file is not a CSV file, so it should be a LEMON database.
        classify_Carpenter_db(ca)
    else:  
        print "This program only process LEMON databases, not CSV files."        
    
    # Return the result of processing program arguments.
    return args_processing_result

# Run 'main' function as __main__.
if __name__ == "__main__":
    main()