#! /usr/bin/env python

# Copyright (c) 2012 Felipe Gallego. All rights reserved.
#
# CLAVEL is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""
This module predicts the type of variability for stars.
The variability is predicted from the light curves of the stars. This
program calculates several features from these light curves that are
processed by means of machine learning techniques. 
The stars are retrieved from a database generated by LEMON 
(https://github.com/vterron/lemon/). 

"""

import classifargs
import starclasses
import starfeatures
import trainevalsets
import evaluation
from sklearn.ensemble import RandomForestClassifier

def train(number_of_trees, star_classes, tr_ev_sets, features):
    """ Performs the training with the set of features and classes received. """
    
    # Get the indexes of the training instances and 
    # the corresponding classes identifier.
    training_indexes, training_classes = tr_ev_sets.training_indexes()
    
    # Creates the training set of features from the set of all the features and
    # the set of indexes to use for training.
    features_of_training_set = []
     
    for i in training_indexes:
        try:
            features_of_training_set.append(features[i])
        except IndexError:
            print "error features[i] en %d" % i
    
    # Get the classifier.
    clf = RandomForestClassifier(number_of_trees)
    
    # Train using the training set and the numerical identifiers for the classes.
    clf = clf.fit(features_of_training_set, training_classes)
    
    return clf

def predict(clf, evaluation_indexes, features):
    """ Performs the prediction with the set of features and classes received. 
        Returns the numeric identifiers of each predicted class.
    
    """      
    
    # To save the predictions for each instance.
    predicted_classes = []
    
    print "evaluation_indexes %s" % evaluation_indexes
    
    # For each instance in the evaluation set. 
    for index in evaluation_indexes:
        # Predict class for current instance.
        predicted_class = clf.predict(features[index])
        # Save prediction.
        predicted_classes.append(predicted_class[0])  
        
    return predicted_classes
        
def train_and_predict(classifarg):
    """ Performs the training for a set of stars and predict the class 
        for another set of stars. 
        
    """
    
    # Get the stars whose classes are known.    
    star_classes = starclasses.StarClasses(classifarg.stars_file)
    
    # Calculate the features of the stars whose identifiers are 
    # indicated and return all the features in a data structure.
    # It is done at first to detect any problem with data reading or 
    # feature calculations, so the star can be discarded.
    stars_features = starfeatures.StarsFeatures(star_classes)
    stars_features.get_features(classifarg)        
    
    # Calculates the training and evaluation sets.
    tr_ev_sets = trainevalsets.TrainEvalSet(classifarg, star_classes)    
    tr_ev_sets.calculate_training_and_evaluation_sets()

    # Train and evaluate for all the filters.
    for nfilter in range(star_classes.number_of_filters):
        # Perform training
        clf = train(classifarg.number_of_trees, 
                    star_classes,
                    tr_ev_sets,
                    star_classes.get_filter_features(nfilter))
        
        evaluation_indexes, evaluation_classes = tr_ev_sets.evaluation_indexes()
        
        # Predict.
        predicted_classes = predict(clf, evaluation_indexes, 
                                    star_classes.get_filter_features(nfilter)) 
        
        # Evaluate prediction.
        evaluat = evaluation.Evaluation(predicted_classes, 
                                        evaluation_classes,
                                        star_classes,
                                        star_classes.filter_name(nfilter))
        
        evaluat.generate_confusion_matrix()

def main(): 
    """ Main function. Process program arguments and determine if the stars
    to process are going to be retrieved from a LEMON database or any other
    source. The only argument necessary is the first one, related to the
    name of the file. """
    
    # Create object to process program arguments.
    ca = classifargs.ClassifierArguments()
    
    # Process program arguments.
    ca.parse()
    
    if ca.is_training():
        pass               
    elif ca.is_prediction():
        pass        
    elif  ca.is_evaluation():
        train_and_predict(ca)       

# Run 'main' function as __main__.
if __name__ == "__main__":
    main()