#! /usr/bin/env python

# Copyright (c) 2012 Felipe Gallego. All rights reserved.
#
# CLAVEL is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

"""
This module predicts the type of variability of stars.
The variability is predicted from the light curves of the stars. This
program calculates several features from these light curves that are
processed with machine learning techniques. 
The stars are retrieved from a database generated by LEMON 
(https://github.com/vterron/lemon/) or from a csv file containing
the features of the stars. 

"""

import sys
import logging
import csv
import csvdata
import classifargs
import modelserial
import starclasses
import starfeatures
import trainevalsets
import evaluation
from sklearn.ensemble import RandomForestClassifier

def init_log(classifarg):
    """ Initializes the file log and messages format. 
    
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.
    
    """
    
    # Initially this software is intended to be used in unix systems.
    # By default a null device is used for log.
    log_file = '/dev/null'
    
    # If a file name has been provided as program argument use it.
    if classifarg.log_file_provided:
        log_file = classifarg.log_file_name
    
    # Format of log messages.
    logging.basicConfig(filename=log_file, format='%(asctime)s:%(levelname)s:%(message)s', level=logging.DEBUG)
    
def error_exit(msg): 
    """ Log the message received and exit using the same message. 
    
        msg - Message to log and use when exiting.
    """
    
    logging.error(msg)
    sys.exit(msg)

def train_for_evaluation(classifarg, star_classes, tr_ev_sets, nfilter):
    """ As part of the evaluation process, performs the step of training
        using the stars chosen for training. This training is performed 
        with the data of the filter indicated. As result of this training,
        it is returned the classifier for this filter. 
    
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.
        star_classes - StarClasses object, it contains all the information
            related to the stars.
        tr_ev_sets - TrainEvalSet object, it contains the information
            related to the sets of stars chosen for training and evaluation.
        nfilter - Name of the filter to be processed.
    
    """
    
    # Get the indexes of the training instances and 
    # the corresponding classes identifier.
    training_indexes, training_classes = tr_ev_sets.training_indexes()
    
    # To store the features of the stars belonging to the training set.
    features_of_training_set = []
    
    # Get the features of all the stars in the filter indicated.
    features = star_classes.get_filter_features(nfilter)
     
    # Select the features of the stars selected for training.
    for i in training_indexes:
        try:                        
            features_of_training_set.append(features[i])
        except IndexError:
            error_exit('Error collecting the set of features for training.')
            
    # To store the classification model.
    clf = None
    
    # if the model has not been read from file generate it.
    if clf == None:  
        filter_name = star_classes.filter_name(nfilter)        
        
        logging.info('Creating Random Forest classifier for filter %s.' % filter_name)      
        clf = RandomForestClassifier(classifarg.number_of_trees)
        
        # Train the classifier using the training set and 
        # the numerical identifiers for the classes.
        clf = clf.fit(features_of_training_set, training_classes)
        
        # If a model file has been provided, write the model generated to file.
        if classifarg.model_file_provided():  
            cm = modelserial.ClassifModel()                            
            cm.save_model(clf, classifarg.model_file_name, filter_name) 
            
            scm = modelserial.StarClassNames(star_classes.unique_classes_names)
            scm.write()
                
    return clf

def predict_for_evaluation(clf, evaluation_indexes, features):
    """ Performs the prediction with the set of stars selected for evaluation. 
        Returns the set of names of each predicted class corresponding to each
        evaluation index.
        
        clf - Classifier to use for prediction.
        evaluation_indexes - Indexes of the stars selected for evaluation.
        features - Set of features of all the stars.
    
    """      
    
    # To save the predictions for each instance.
    predicted_classes = []
    
    # For each instance in the evaluation set. 
    for index in evaluation_indexes:
        # Predict class for current instance.
        predicted_class = clf.predict(features[index])
        # Save prediction.
        predicted_classes.append(predicted_class[0])
        
    return predicted_classes
        
def retrieve_stars_features(classifarg):
    """ Read the stars information and loads it in the structures used.
        The information is read from the source indicated by the program
        arguments.
        Returns StarClasses object containing all the information read
        for the stars.
        
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.        
    
    """
    
    logging.info('Getting stars features.')
    
    # Get an object to store the stars information.
    star_classes = starclasses.StarClasses()  
    
    # Get the stars identification from the source indicated by program arguments.
    if classifarg.stars_id_file_provided:
        star_classes.retrieve_stars_classes_from_file(classifarg.stars_id_file_name)
    elif classifarg.database_file_provided:
        star_classes.retrieve_stars_classes_from_database(classifarg.database_file_name)
    elif classifarg.features_file_provided:
        star_classes.retrieve_stars_classes_from_features_file(classifarg.features_file_name)               
    else:
        error_exit("It hasn't been specified an origin for the stars identification.")
    
    if star_classes.stars_identifiers == 0:
        error_exit('Not found any features file.')
        
    # Calculate the features of the stars whose identifiers are
    # indicated and return all the features in a data structure.
    # It is done at this point to detect any problem with data reading or
    # feature calculations, thus the star can be discarded from first steps.
    stars_features = starfeatures.StarsFeatures(star_classes)
    stars_features.retrieve_features(classifarg)
    
    return star_classes

def evaluate_classifier(classifarg):
    """ Performs the complete process of evaluation using a set of stars.
        This evaluation requires two steps. The first is the training using 
        the a subset of stars and the prediction of the class for the rest 
        of stars in order to evaluate the success of the classification 
        performed. 
        
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.           
        
    """       
    
    logging.info('Reading stars information.')
    
    # Read stars information. 
    star_classes = retrieve_stars_features(classifarg)    
    
    # Calculates the training and evaluation sets.
    tr_ev_sets = trainevalsets.TrainEvalSet(classifarg, star_classes)    
    tr_ev_sets.calculate_training_and_evaluation_sets()

    # Train and evaluate for all the filters.
    for nfilter in range(star_classes.number_of_filters):
        # Perform training.
        clf = train_for_evaluation(classifarg, star_classes, tr_ev_sets, nfilter)
        
        evaluation_indexes, evaluation_classes = tr_ev_sets.evaluation_indexes()
        
        # Predict.
        predicted_classes = predict_for_evaluation(clf, evaluation_indexes, 
                                    star_classes.get_filter_features(nfilter)) 
        
        # Evaluate prediction.
        evaluat = evaluation.Evaluation(predicted_classes, 
                                        evaluation_classes,
                                        tr_ev_sets.training_classes,
                                        star_classes.filter_name(nfilter))
        
        # Generate the confusion matrix in a csv file.
        evaluat.generate_confusion_matrix()   

def only_training(classifarg):
    """ Performs only training with the data received.
        Read the star list to use for training and generates 
        the classification model. 
        
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.         
     
    """
    
    if classifarg.model_file_provided():
        logging.info('Reading stars information.')
        
        # Read stars information. 
        star_classes = retrieve_stars_features(classifarg)        
        
        # Establish the training set.
        tr_ev_sets = trainevalsets.TrainEvalSet(classifarg, star_classes)
        tr_ev_sets.set_all_stars_for_training()
        
        # Train for all the filters.
        for nfilter in range(star_classes.number_of_filters):
            train_for_evaluation(classifarg, star_classes, tr_ev_sets, nfilter)
    else:
        error_exit('For training a file name to save the model must be provided.')
                
def write_prediction_to_file(afilter, star_classes, predicted_classes, classifarg):
    """ Writes to a csv file the prediction of a given filter.
    
        afilter - Name of the filter applicable to this prediction.
        star_classes - StarClasses object, it contains all the information
            related to the stars.
        predicted_classes - The list of predicted classes.
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.
    
    """        
    
    # Compose the name of the prediction file.
    prediction_file_name = classifarg.prediction_file + '_' + afilter + csvdata.CsvUtil.FILE_EXT   
    
    # Get the list of star classes.
    unique_classes_names = star_classes.unique_classes_names
    
    # Write the file.
    with open(prediction_file_name, 'wb') as csvfile:
        logging.info("Writing prediction for filter %s to file: %s" % (afilter, prediction_file_name))
                
        csv_file = csv.writer(csvfile, delimiter=',', quotechar='"')  
        
        # Write header.
        row = [csvdata.CsvUtil.ID, csvdata.CsvUtil.PREDICTION]
        csv_file.writerow(row)
        
        # Get the identifiers for all the stars.
        stars_identifiers = star_classes.stars_identifiers
                
        # Write csv rows. Each row contains a star identifier and 
        # the class predicted.
        for star_id, predict in zip(stars_identifiers, predicted_classes):
            
            row = [star_id, unique_classes_names[(int(predict))]] 
            csv_file.writerow(row)      
     
def predict_stars_classes(clf, filters_names, star_classes, classifarg):
    """  Predict star classes using the model and the stars received.
    
        clf - List of classifiers.
        filters_names - List of filter names corresponding to the classifiers.
        star_classes - StarClasses object, it contains all the information
            related to the stars.
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.
    """    
    
    # Perform the prediction for each filter.
    for classifier, afilter in zip(clf, filters_names):
        logging.info('Predicting class for stars using filter %s', afilter)
        
        # Get the features of the stars for current filter.
        features = star_classes.get_features_by_filter_name(afilter)
        
        # To save the predictions for each instance.
        predicted_classes = []
        
        # For each instance in the evaluation set. 
        for i in range(len(features)):          
            # Prior to predict the class of the star, check if the star is enabled.
            if star_classes.is_enabled(i):            
                # Predict class for current instance.
                predicted_class = classifier.predict(features[i])
                # Save prediction.
                predicted_classes.append(predicted_class[0])        
        
        write_prediction_to_file(afilter, star_classes, predicted_classes, classifarg)  
        
        # Write confusion matrix.
        evaluat = evaluation.Evaluation(predicted_classes,
                                        range(len(star_classes.unique_classes_names)), 
                                        star_classes.unique_classes_names,
                                        afilter)
        
        # Generates the confusion matrix corresponding to the current filter.
        evaluat.generate_confusion_matrix()
        
def only_prediction(classifarg):
    """ Performs only the prediction of the class for a set of stars.
        To accomplish this task the stars and the classifier model must be read.
        
        classifarg - ClassifierArguments object, it contains the
            information of all program arguments received.        
        
    """

    # If a model file has been provided, read it from file.
    if classifarg.model_file_provided():        
        # Try to read the model file, it couldn't exist.
        cm = modelserial.ClassifModel()            
        
        clf, filters_names = cm.read_model(classifarg.model_file_name)  
        
        if clf <> None:
            # Retrieve the information of stars to predict.
            star_classes = retrieve_stars_features(classifarg)
            
            predict_stars_classes(clf, filters_names, star_classes, classifarg)
        else:
            error_exit("The classification model can't be read, prediction cann't be done.")          
    else:
        error_exit("A file with a classification model hasn't been provided, prediction cann't be done.")

def main(): 
    """ Main function used to perform training, prediction or evaluation 
    depending on the arguments received. Process program arguments and 
    determine if the stars to process are going to be retrieved from a 
    LEMON database or any other source. 
    
    """
    
    # Create object to process program arguments.
    ca = classifargs.ClassifierArguments()
    
    # Process program arguments.
    ca.parse()     
    
    init_log(ca)
    
    logging.info('----- Clavel started ---------------------------------------')
    
    # Check that all the program arguments received are coherent.
    if ca.check_arguments_set():
    
        # Performs the action indicated by the programs arguments.
        if ca.is_training:
            logging.info("Let's go training!")        
            only_training(ca)
                           
        elif ca.is_prediction:
            logging.info("Let's go prediction!")
            only_prediction(ca)        
            
        elif ca.is_evaluation:
            logging.info("Let's go evaluation!")        
            evaluate_classifier(ca)   

        logging.info('Clavel finished.')      
        
    else:
        error_exit("Program arguments aren't coherent.")      

# Run 'main' function as __main__.
if __name__ == "__main__":
    main()